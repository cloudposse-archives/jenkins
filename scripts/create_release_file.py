#!/usr/bin/env python
import argparse
import errno
import hcl
import json
import logging
import os
import os.path
import subprocess

from shutil import copy2

logger = logging.basicConfig(level=logging.DEBUG,
                             format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

LOGGER = logging.getLogger(__name__)

parser = argparse.ArgumentParser(description="Create a release file")
parser.add_argument('--source_env', help='The environment that you want to deploy')
parser.add_argument('--source_version', help='The version we want to deploy')
parser.add_argument('--target_env', help='The environment you want to create a new release file for')
parser.add_argument('--version', help='The version new version we are deploying (generated by Jenkins)')

args = parser.parse_args()
source_env = args.source_env
source_version = args.source_version
target_env = args.target_env
version = args.version

m2a_ci_url = "git@bitbucket.org:m2amedia/m2a-ci.git"


def update_m2a_ci(environ, build_version):
    """

    :param build_version: the version number generated by jenkins
    """
    git_runner = GitRunner('/usr/bin/git', LOGGER)
    sources = get_sources_from_modules(environ)
    git_urls = [m2a_ci_url]
    for source in sources:
        git_urls.append(get_url_from_source(source))

    modules_data = {}
    for url in git_urls:
        cmd = git_runner.create_cmd_for_remote_repo(url)
        sha = git_runner.run_cmd(cmd)
        modules_data[get_module_name_from_url(url)] = {"sha": sha.split('\t', 1)[0]}
    print(modules_data)
    create_release_file(modules_data, environ, build_version)


def deploy_to_new_env(env_from, env_to, version_from_source, build_version):
    """
    :param env_from: the environment we are wanting to recreate
    :param env_to: the environment we are deploying too
    :param version_from_source: the version we want to deploy
    :param build_version: the version number generated by jenkins
    """
    git_runner = GitRunner('/usr/bin/git', LOGGER)
    copy_release_file(env_from, env_to, version_from_source, build_version)


def get_sources_from_modules(environment):
    """
    :param environment: Which directory in m2a-ci we will find our modules.tf files
    :return: a list of the sources for the modules in the environment
    """
    sources = []
    for dir_path, dir_names, file_names in os.walk('m2a-ci/{}'.format(environment)):
        for file_name in [f for f in file_names if f == "modules.tf"]:
            with open(os.path.join(dir_path, file_name), "r") as my_file:
                modules_tf = hcl.load(my_file)
                for source in modules_tf["module"].values():
                    sources.append(source["source"])

    return sources


def create_release_file(module_data, environment, version):
    """
    :param module_data: a JSON object showing module git urls and their SHA
    :param environment: which environment we are creating a release file for
    :param version: the version of the release
    """
    path = "m2a-releases/{}/{}.json".format(environment, version)
    if not os.path.exists(os.path.dirname(path)):
        try:
            os.makedirs(os.path.dirname(path))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    with open(path, "w+") as new_file:
        json.dump(module_data, new_file)


class GitRunner:
    def __init__(self, path_to_binary, logger):
        self.path_to_binary = path_to_binary
        self.logger = logger

    def run_cmd(self, cmd):
        try:
            process = subprocess.Popen(cmd,
                                       shell=False,
                                       stderr=subprocess.STDOUT,
                                       stdout=subprocess.PIPE)
            output, stderr = process.communicate()
            ret_code = process.wait()
            if ret_code == 0:
                return output
            else:
                error_message = "ERROR whilst running cmd {} - error {} ".format(cmd, stderr)
                self.logger.error(error_message)
                raise UserWarning(error_message)
        except Exception as ex:
            self.logger.error("ERROR whilst running cmd {} - error {} ".format(cmd, ex))
            raise ex

    def create_cmd_for_remote_repo(self, remote_path):
        return [
            self.path_to_binary,
            "ls-remote",
            remote_path,
            "master"
        ]

    def create_cmd_for_checkout_sha(self, sha):
        return [
            self.path_to_binary,
            "checkout",
            sha
        ]


def get_url_from_source(source):
    try:
        url_start = source.index('//') + 2
        url_end = source.rindex('//')
        return source[url_start:url_end].replace('/', ':', 1)

    except ValueError:
        print("Source malformed, cannot find url")


def get_module_name_from_url(url):
    try:
        name_start = url.rindex('/') + 1
        name_end = url.rindex('.git')
        return url[name_start:name_end]

    except ValueError:
        print("Source malformed, cannot find module name")


def copy_release_file(env_from, env_to, version_from_source, new_version):
    copy2("m2a-releases/{}/{}".format(env_from, version_from_source),
          "m2a-releases/{}/{}".format(env_to, new_version))


if target_env is None:
    update_m2a_ci('m2aci', version)
else:
    deploy_to_new_env(source_env, target_env, source_version, version)
